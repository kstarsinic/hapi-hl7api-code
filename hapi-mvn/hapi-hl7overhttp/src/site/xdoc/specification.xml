<?xml version="1.0" encoding="UTF-8"?>
<document xmlns="http://maven.apache.org/XDOC/2.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">

	<properties>
		<title>HL7 over HTTP</title>
		<author email="jamesagnew@users.sourceforge.net">James Agnew</author>
	</properties>

	<body>

		<section name="Specification">

		    <p style="margin-left: 20px; margin-right: 20px; background: #FFC0C0; border: #C0A0A0 dashed 1px; padding: 20px;">
		        This document is a DRAFT for comments. Please submit comments the
		        <a href="http://hl7api.sourceforge.net/mail-lists.html">HAPI Mailing List</a>
		        or by contacting directly at
		        <a href="mailto:jamesagnew@users.sourceforge.net">jamesagnew@users.sourceforge.net</a>
		    </p>
		    
			<p>
				HL7 over HTTP is an initiative to provide a standardized
				transport mechanism to send HL7 v2 messages over a network
				using the HTTP protocol.
			</p>
			<p>
				Requirement levels (MUST, SHOULD, etc.) are used according to
				RFC 2119 (<a href="http://www.ietf.org/rfc/rfc2119.txt">http://www.ietf.org/rfc/rfc2119.txt</a>).
			</p>

			<subsection name="Contents">
				<macro name="toc">
					<param name="section" value="2"/>
					<param name="fromDepth" value="0"/>
					<param name="toDepth" value="2"/>
				</macro>
				<macro name="toc">
					<param name="section" value="3"/>
					<param name="fromDepth" value="0"/>
					<param name="toDepth" value="2"/>
				</macro>
				<macro name="toc">
					<param name="section" value="4"/>
					<param name="fromDepth" value="0"/>
					<param name="toDepth" value="2"/>
				</macro>
			</subsection>

			<subsection name="Intent">
				
				<p>
					HL7 over HTTP is an alternative to the traditional
					Minimal Lower Layer Protocol (MLLP), but provides a number
					of key improvements:
				</p>
				<ul>
					<li>
						HTTP is widely used for a variety of purposes, and is
						well understood by application developers, network engineers, etc.
					</li>
					<li>
						HTTP allows for authentication (username/password) and character
						set encoding to be specified in a standardized way, without having to
						embed this information in the message itself.
					</li>
					<li>
						Tool and hardware support for HTTP is widespread, with many specialized
						software and hardware devices providing enhanced support for common
						protocols such as HTTP. 
					</li>
				</ul>
				<p>
					This document is intended to provide a standard implementable specification
					which application developers may use as a reference in order to 
					build interoperable software. 
				</p>
			
			</subsection>
			
		</section>
		<section name="1.0 - Basic Profile">

			<p>
				HL7 over HTTP uses the standard HTTP/1.1 protocol 
				(<a href="http://www.ietf.org/rfc/rfc2616.txt">RFC 2616</a>)
				as a mechanism to transfer
				a raw HL7 message using either ER7 or XML encoding to a destination, and then
				to receive a response to that message. A standard interaction is shown below.  
			</p>

			<img src="images/HoH_Trace_Normal.png"/>
				
			<subsection name="1.1 Transport Messages">
			
				<p>
					Every interaction consists of a <b>request message</b> and a <b>response message</b>.
					In a normal message exchange, the receiving system opens a server socket. The
					sending system then connects to that socket and uses the HTTP POST action to 
					transmit a message. The receiving system then replies with an HTTP 200 OK,
					and transmits the response message (typically an HL7 ACK) in the body of the
					response.
				</p>		
			
				<p>
				    Request and response messages use the following headers:
				</p>
				
				<h4>Addressing</h4>
				
				<p>
					The <b>request message</b> SHALL include a universal resource identifier (URI), per the
					HTTP specification. This URI SHOULD indicate
					the appropriate "interface" for the message. This is analogous to the port number in 
					a standard 
					<dfn title="Minimal Lower Layer Protocol">MLLP</dfn> 
					configuration. 
				</p>
				<p>
					For example, a receiving laboratory information system application might open an 
					HTTP server on port 1234 which is capable of receiving several types of data. The 
					sending system could then address ADT data to the receiving system's ADT queue using 
					the following POST request<br/>
				</p>
				<source>POST /Lab_Info_System/ADT HTTP/1.1</source>
				
				<p>
					An implementing receiving system MAY also choose to use a separate port for each
					interface, as is the norm for MLLP interfaces. This is acceptable and will work,
					but is not desirable as it is not common practise in HTTP applications. 
				</p>
			
				<h4>Content Length</h4>
				
				<p>
					The <b>request message</b> and the <b>response message</b> SHALL include a
					<code>Content-Length</code> header, which indicates the number of bytes in
					the HL7 message itself. Per the HTTP specification, this number excludes any
					bytes found within the HTTP headers and the two carriage returns which follow 
					them, but includes any further whitespace which will be counted as a part of
					the message body. Depending on the character set encoding, the content length 
					might exceed the number of characters as some characters will be represented as
					multi-byte sequences (e.g. in UTF-8). An example follows, which indicates that the message contents
					consist of 2553 bytes.<br/>
				</p>
				<source>Content-Length: 2553</source>  

				<h4>Authorization</h4>
				
				<p>
				    <b>Request messages</b> SHOULD include an Authorization header which
				    contains credentials which are shared between the sending and receiving
				    system.
				</p>
				<p>
				    The HL7 over HTTP specification allows only the use of HTTP Basic Authentication,
				    as it has been shown that HTTP Digest Authentication does not add further security
				    due to a reliance on insecure MD5 hashing and adds complexity to implementation.
				</p>
				<p>
				    The following example shows an Authorization block containing the username
				    "hello" and the password "world". As described in the HTTP/1.1 specification,
				    the resulting string consists of the string "hello:world" with a Base64 encoding
				    applied to it:
				</p>
				<source>Authorization: Basic aGVsbG86d29ybGQ=</source> 
				<p>
				    If a <b>sending application</b> sends a message without an 
				    <code>Authentication</code> header and the <b>receiving application</b> 
				    responds with a response of HTTP 401 and a <code>WWW-Authenticate</code> 
				    header, the <b>sending application</b> MAY resend it together 
				    with the <code>Authentication</code> Header 
				    as described in 
				    <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.2">section 10.4.2</a>
				    of RFC 2616.
				</p>
				
				<h4>Host</h4>
				<p>
				    As required by the HTTP/1.1 specification, <b>Request Messages</b>
				    MUST include a Host header, which specifies the host name and
				    port being identified.  
				</p>
				<source>Host: somehost.company.ca:19000</source> 
								
				<h4>Transfer-Encoding</h4>
				<p>
				    <b>Receiving applications</b> MUST be capable of decoding content which
				    has been encoded with "chunked" transfer encoding. Although this style is
				    not generally useful for transactional messages such as HL7, intermediate
				    devices and third party libraries may introduce this style unexpectedly.      
				</p>
				<p>
				    <b>Sending applications</b> MAY choose to send data using chunked encoding.
				</p>
				<source>Transfer-Encoding: chunked</source> 
				
			</subsection>

			<subsection name="1.2 Content Type and Character Set">
				
				<p>
					The <b>request message</b> and the <b>response message</b> SHALL include a
					<code>Content-Type</code> header, which indicates the type of data being 
					transferred. The following MIME types apply:
					<ul>
						<li>
							If the message is an ER7 (vertical bar) encoded message, the
							content type SHALL be:<br/>
							<code>&nbsp;&nbsp;&nbsp;&nbsp;application/hl7-v2</code>
						</li>
						<li>
							If the message is an XML encoded message, the
							content type SHALL be:<br/>
							<code>&nbsp;&nbsp;&nbsp;&nbsp;application/hl7-v2+xml</code>
						</li>
						<li>
							If the <b>response message</b> content is not an HL7 message
							(for instance because the server is malfunctioning and returning a 500 status or the URI being 
							addressed is unknown and the server is returning a 404 status),
							the content MAY be another type, such as<br/>
							<code>&nbsp;&nbsp;&nbsp;&nbsp;text/html</code> or <code>text/plain</code>
						</li>
					</ul>
				</p>
				
				<h4>Character Set</h4>
				
				<p>
					In addition, both the <b>request message</b> and the <b>response message</b> SHALL
					include a charset definition which indicates which character encoding is being used
					for the message body. Note that the HL7 specification allows the character set to be
					specified in MSH-18. When a message is received using HL7 over HTTP, this value SHALL
					be ignored. When a message is sent using HL7 over HTTP, the sending application MAY 
					choose to use the value in MSH-18 to inform the choice of charset, but it is not
					obligated to do so.
				</p>
				<p>
					An example follows which shows an ER7 encoded message being
					transmitted using a character encoding of ISO-8859-4.
				</p>
				<source>Content-Type: application/hl7-v2; charset=ISO-8859-4</source>
				
				<h4>Response Character Set</h4>
				
				<p>
				    If the <b>request message</b> contains an explicit charset definition,
				    the <b>Receiving Application</b> SHOULD attempt to use the same
				    charset in the <b>response message</b>.
				</p>
				
				<!--
				Is this worth doing? Probably not, since the request message is
				usually where most of the contents are....
				 
				<p>
				    The <b>request message</b> MAY include the <code>Accept-Charset</code>
				    header to indicate a preferred charset to be used by the response.
				</p>
				 -->
				
				<h4>Date</h4>
				
				<p>
				    Where possible, <b>Request messages</b> and <b>response messages</b>
				    SHOULD provide a date header which matches the HL7 message timestamp 
				    found in the HL7 message within MSH-7. If the HL7 message does not have
				    a value in MSH-7, or if the value lacks sufficient precision to form
				    an appropriate value, applications MAY use the current system time. 
				</p>
				
			</subsection>
									
			<subsection name="1.3 HTTP Response Codes">
			    
			    <p>
			        If a <b>receiving application</b> is able to process a received
			        HL7 message and produce a corresponding response (typically an ACK, RSP_xxx, etc.),
			        the HL7 Acknowledgement Code (MSA-1) SHOULD dictate the HTTP response
			        code used. 
			    </p>
			    
			    <p>
			        When a message is received by a <b>receiving application</b> and 
			        is successfully processed, the receiving application 
			        responds with an HL7 message containing a positive acknowledgement
			        code of Application Accept (AA) or Commit Accept (CA). The HL7 over
			        HTTP transport SHOULD respond with an HTTP status codee of 
			        <code>HTTP/1.1 200 OK</code>.
			    </p>
			    
			    <p>
			        If the underlying receiving application rejects the incoming message
			        for some reason, it will typically generate an HL7 ACK response message
			        containing a non-success status code. The following section outlines possible
			        error responses. 
			    </p>
			    
			    <h4>Application Reject (AR) and Commit Reject (CR)</h4>
			    <br/>
			    
			    <p>
			        If the receiving application rejects the incoming message with an AR or CR
			        status, the receiving application SHALL return a response of
			        <code>HTTP/1.1 400 Bad Request</code>. The body of the response SHALL contain the
			        actual HL7 message which was generated.  
			    </p>
			    
			    <img src="images/HoH_AR.png"/>
			    
			    <h4>Application Error (AE) and Commit Error (CE)</h4>
			    <br/>
			    
			    <p>
			        If the receiving application experiences an error during processing
			        and returns a status of AE or CE,  
			        the receiving application SHALL return a response of
			        <code>HTTP/1.1 500 Internal Server Error</code>. The body of the response SHALL contain the
			        actual HL7 message which was generated.  
			    </p>
			    
			    <img src="images/HoH_AE.png"/>

			    <h4>HTTP Errors</h4>
			    <br/>
			    
			    <p>
			        If the receiving application is unable to process the message it receives
			        in a request (e.g. because it is addressed to an unknown URI, or it is 
			        not a valid message) the HTTP/1.1 specification defines a number of 4xx response codes
			        which may be returned. Receiving applications MAY return any valid 4xx response
			        code. Receiving applications MAY return HTTP 401, but only in the case 
			        of authorization failures.
			    </p>
			    <p>
			        If the receiving application experiences an error outside of the core
			        HL7 processing logic (e.g. because the HTTP server itself if not working
			        correctly) the HTTP/1.1 specification defines a number of 5xx response codes
			        which may be returned. Receiving applications MAY return any valid 5xx response
			        code.
			    </p>
			    <p>
					If no HL7 response message is generated and the <b>receiving application</b>
					wishes to indicate an error,
					the <b>receiving application</b> MAY use any content type to encode the response
					message. Note that using a content type of <code>text/plain</code> may increase
					readability within system logs.  
			    </p>
			    
			    <img src="images/HoH_Error_500.png"/>

			</subsection>

			<subsection name="1.4 Compression">
			
				<p>
					<b>Sending applications</b> and <b>receiving applications</b> implementing this specification 
					MAY support the ability to compress contents using the GZip algorithm, as defined in the
					HTTP/1.1 specification.
				</p>
				<p>
					Note that GZip should only be used if it is explicitly enabled, as its use can incur
					a performance penalty.  
				</p> 
					
			</subsection>
			
			<subsection name="1.5 Persistent Connection">
			
				<p>
					<b>Sending applications</b> MAY use a persistent connection as defined in the 
					HTTP/1.1 specification. When using a persistent connection, the sending application
					MUST include a <code>Content-Length</code> header. Content Chunking MUST NOT be used. 
				</p>
				<p>
					<b>Receiving applications</b> SHOULD allow the use of a persistent connection.
				</p>
					
			</subsection>

			<subsection name="1.6 Support for Other Parts of HTTP/1.1">
				
				<p>
					Implementations are NOT REQUIRED to support any feature of the HTTP/1.1 specification
					not explicitly referenced in this document. Implementations MUST NOT assume that 
					any feature of the HTTP/1.1 specification
					not explicitly referenced in this document is supported by a trading partner.
				</p>
			
			</subsection>
			
		</section>

		
		<section name="2.0 - Security Profile"  style="clear: both;">

			<subsection name="2.1 Algorithms">
			
				<p>
					<b>Sending applications</b> and <b>receiving applications</b> implementing this profile 
					MUST additionally support the ability to communicate using HTTPS, i.e.
					using Transport Layer Security (TLS), version 1.0 
					(RFC 2246, <a href="http://www.ietf.org/rfc/rfc2246.txt">http://www.ietf.org/rfc/rfc2246.txt</a>) or later. 
					Transport Layer Security provides the possibility for end-to-end encryption and mutual authentication.
				</p>
				<p>
					Security Profile includes all requirements of Basic Profile, except that HTTP Basic Authentication
					can be omitted when TLS Mutual Authentication is being used.
				</p>
				<p>
					The certificates used SHALL be X.509 certificates based on RSA key with
					a key length in the range between 1024 and 4096. Supported cipher suites SHALL include
					TLS_RSA_WITH_AES_128_CBC_SHA, other ciphers MAY be chosen based on site-specific policies.
				</p>
				
			</subsection>

			<subsection name="2.2 Mutual authentication">
			
				<p>
					Sending and receiving applications implementing this profile SHOULD support mutual
					authentication as specified in the TLS specification. Here, the client additionally presents a
					X.509 client certificate to the server in order to authenticate its access. In this case,
					HTTP Basic Authentication SHOULD NOT be used.
				</p>
				
			</subsection>
			
			<subsection name="2.3 Self-signed certificates">
			
				<p>
					In many cases, it is appropriate to use a self-signed certificate for system-to-system HL7
					communication. For this reason,
					<b>receiving application</b> implementors are recommended to provide support and/or guidance 
					for generating and using self-signed certificates, and  <b>sending application</b> implementors are 
					recommended to provide support for importing them.     
				</p>
				<p>
					All further details about governance of issuing or revoking certificates are
					out of scope for this specification.
				</p>
				
			</subsection>
					
		</section>
			
		<a name="SIGNATURE_PROFILE"/>
		<section name="3.0 - Signature Profile"  style="clear: both;">

		    <p>
		        Signature Profile is an optional addition to the HL7 over HTTP specification
		        which provides message non-repudiation. Put simply, when combined with a two
		        certificate pairs, Signature Profile allows the <b>receiving application</b>
		        to strongly verify the identity of the 
		        <b>sending application</b> 
		        sending the message, and vice-versa. It also provides evidence that the message 
		        has not been altered in any way during transit.
		    </p>			    
			<p>
			    Signature Profile includes all requirements of Basic Profile, and does not depend
				on the Security profile as specified in section 2.
			    To implement Signature Profile, <b>Request messages</b> and <b>response messages</b> 
			    SHALL include an 
			    HTTP header containing a cryptographic signature which is generated
			    against a hash of the message payload (note that the payload
			    includes only the raw HL7 message and therefore excludes the HTTP headers
			    and any other content which is part of the HTTP protocol itself). 
			</p>
			<p>
			    The format of the signature itself is that of the Cryptographic
			    Message Syntax (CMS) as defined in
			    <a href="http://www.ietf.org/rfc/rfc3852.txt">RFC 3852</a>. The signature
			    SHOULD NOT include an encrypted copy of the message payload itself,
			    only a signature (this is sometimes referred to as a "detached signature").
			</p>
			<p>
				Note that if compression is applied to the message contents, the signature
				must be generated against the uncompressed contents.
			</p>
			<p>
			    The format of the signature header is as follows:<br/>
			</p>				    
		    <source>HL7-Signature: [Algorighm] [Signature]</source>
		     
			<p>
			    The algorithm MAY be substituted based on agreement between the sending
			    and receiving system, but support for SHA512 digest with an RSA signature
			    (with algorithm name "SHA512withRSA") is required for compliance with
			    Signature Profile.
			</p>
			<p>
			    The following example shows a Signature Profile header which has been truncated
			    for readability:<br/>
			</p>
		    <source>HL7-Signature: SHA512withRSA bUOp4sm46qk0pdm9Xv2Br [...]</source> 
		    
		</section>
						
	</body>

</document>
